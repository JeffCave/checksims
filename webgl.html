<!doctype html>
<html lang="en">
  <head>
   <meta charset="utf-8">
   <title>WebGL Demo</title>
   <style>
	body{
		font-family:monospace;
	}
	canvas{
		border:1em solid #888888;
	}
	table{
		text-align:right;
		border-collapse: collapse;
	}
	table, th, td {
		border: 1px solid lightgray;
		white-space: pre;
	}
	td > i{
		 font-style: normal;
	}
	td > i:nth-of-type(1){
		color:red;
	}
	td > i:nth-of-type(2){
		color:green;
	}
	td > i:nth-of-type(3){
		color:blue;
	}
	td > i:nth-of-type(4){
		color:black;
	}
	td > i:nth-of-type(2):after{
		content:"\A";
	}
	table > caption{
		text-align:left;
	}
   </style>
  </head>

 <body>
  <table></table>
  <script>
class pixel{
	constructor(pixels=[0,0,0,0], offset = 0){
		this.offset = offset;
		this.pixels = pixels;
	}

	get r(){ return this.getValue(0); }
	get g(){ return this.getValue(1); }
	get b(){ return this.getValue(2); }
	get a(){ return this.getValue(3); }

	set r(vals){ this.setValue(0,vals); }
	set g(vals){ this.setValue(1,vals); }
	set b(vals){ this.setValue(2,vals); }
	set a(vals){ this.setValue(3,vals); }

	setValue(offset,vals){
		if(vals < 0){
			vals = 0;
		}
		if(vals > 255){
			vals = 255;
		}
		this.pixels[this.offset+offset] = vals;
	}

	getValue(offset){
		let value = this.offset+offset;
		value = this.pixels[value];
		value = pixel.NZ(value);
		return value;
	}

	read(arr,offset){
		this.r = arr[offset+0];
		this.g = arr[offset+1];
		this.b = arr[offset+2];
		this.a = arr[offset+3];
		return offset+4;
	}

	write(arr,offset){
		arr[offset+0] = this.r;
		arr[offset+1] = this.g;
		arr[offset+2] = this.b;
		arr[offset+3] = this.a;
		return offset+4;
	}

	get values(){
		return [
				this.r,
				this.g,
				this.b,
				this.a,
			];
	}

	static NZ(val){
		return val ? val : 0;
	}
}

class psGpu{
	constructor(options={}){
		let opts = psGpu.BaseOpts;
		Object.entries(options).forEach((o)=>{
			opts[o[0]] = o[1];
		});

		let canvas = document.createElement('canvas');
		canvas.height = opts.height;
		canvas.width = opts.width;

		const gl = canvas.getContext('webgl2');
		// If we don't have a GL context, give up now
		if (!gl) {
			throw new Error('Unable to initialize WebGL. Your browser or machine may not support it.');
		}

		this._ = {
			opts: opts,
			gl:gl,
			programs:{},
			buffers:{}
		};

		// Create a dummy program. It does nothing but pass the textures
		// through. It's safe and cheap to run.
		this.addProgram('', `
			precision mediump float;

			// our texture
			uniform sampler2D u_image;
			// the texCoords passed in from the vertex shader.
			varying vec2 v_texCoord;

			void main() {
				gl_FragColor = texture2D(u_image, v_texCoord);
			}
		`);



	}

	get gl(){
		return this._.gl;
	}

	get width(){
		return this.gl.drawingBufferWidth;
	}
	get height(){
		return this.gl.drawingBufferHeight;
	}

	static get BaseOpts(){
		return {
			height:1,
			width:1,
			PixelType: Uint8Array,
		};
	}

	sanitizeRect(dim={}){
		dim.x = dim.x || 0;
		dim.y = dim.y || 0;
		dim.width = dim.width || this.width;
		dim.height = dim.height || this.height;
		if(this.width < dim.width+dim.x){
			dim.width = this.width - dim.x;
		}
		if(this.height < dim.height+dim.y){
			dim.height = this.height - dim.y;
		}

		return dim;
	}

	emptyData(dim={}){
		dim = this.sanitizeRect(dim);
		let pixels = new Uint8Array(dim.width * dim.height * 4);
		return pixels;
	}

	read(dim={}){
		const gl = this.gl;
		dim = this.sanitizeRect(dim);
		let pixels = this.emptyData(dim);

		// grad the buffer that is most appropriate for reading from
		//console.debug('Buffer: ' + this._.textures.read.id + ' -> 😐');
		this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._.textures.read.framebuffer);

		gl.readPixels(dim.x, dim.y, dim.width, dim.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels, 0);
		return pixels;
	}

	write(pixels, dim={}){
		let gl = this.gl;
		dim = this.sanitizeRect(dim);

		// whichever buffer we write to will become the best one to read from
		// may as well just use the current read buffer
		//console.debug('Buffer: 😐 -> ' + this._.textures.read.id);
		this.gl.bindTexture(this.gl.TEXTURE_2D, this._.textures.read.texture);

		gl.texSubImage2D(gl.TEXTURE_2D, 0, dim.x, dim.y, dim.width, dim.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels , 0);
	}

	run(name = ''){
		if(!name){
			name = '';
		}
		if(this.CurrentProgram !== name){
			this.CurrentProgram = name;
			this.initProgram(name);
		}

		// get the read buffer
		let read = this._.textures.read;
		// the write buffer is the one we aren't reading from
		let write = 1-this._.textures.read.id;
		write = this._.textures[write];
		// whichever one we just wrote to is now the one we should be reading from.
		this._.textures.read = write;
		//console.debug('Buffer: ' + read.id + ' -> ' + write.id);

		this.gl.bindTexture(this.gl.TEXTURE_2D, read.texture);
		this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, write.framebuffer);
		this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
	}

	initMemory(){
		let gl = this.gl;

		// Create a buffer to put three 2d clip space points in
		let position = this._.buffers.position = gl.createBuffer();

		// Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
		gl.bindBuffer(gl.ARRAY_BUFFER, position);
		// Set a rectangle the same size as the image.
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
				0                     , 0,
				gl.drawingBufferWidth , 0,
				0                     , gl.drawingBufferHeight,
				0                     , gl.drawingBufferHeight,
				gl.drawingBufferWidth , 0,
				gl.drawingBufferWidth , gl.drawingBufferHeight
			]), gl.STATIC_DRAW);

		// provide texture coordinates for the rectangle.
		let texcoord = this._.buffers.texcoord = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, texcoord);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
				0.0,  0.0,
				1.0,  0.0,
				0.0,  1.0,
				0.0,  1.0,
				1.0,  0.0,
				1.0,  1.0,
			]), gl.STATIC_DRAW);

		// Create a texture.
		const pixel = this.emptyData();
		this._.textures = [0,1].map(d=>{
				let texture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.drawingBufferWidth, gl.drawingBufferHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixel, 0);

				// Not concerned with it being a power of 2
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

				let frameBuffer = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

				return {
					id: d,
					texId: (gl.TEXTURE0+d),
					texture: texture,
					framebuffer: frameBuffer,
				};
			});
		// bind the textures
		this._.textures.read = this._.textures[0];
	}

	initProgram(name) {
		let gl = this.gl;
		// setup GLSL program
		var program = this._.programs[name];

		// look up where the vertex data needs to go.
		let positionLocation = program.attribs.position;
		let texcoordLocation = program.attribs.texcoord;

		// Tell WebGL how to convert from clip space to pixels
		gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

		// Tell it to use our program (pair of shaders)
		gl.useProgram(program.program);

		// Turn on the position attribute
		gl.enableVertexAttribArray(positionLocation);
		gl.bindBuffer(gl.ARRAY_BUFFER, this._.buffers.position);
		gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

		// Turn on the texcoord attribute
		gl.enableVertexAttribArray(texcoordLocation);
		gl.bindBuffer(gl.ARRAY_BUFFER, this._.buffers.texcoord);
		gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);

		// lookup uniforms
		let resolutionLocation = program.uniforms.resolution;
		gl.uniform2f(resolutionLocation, gl.drawingBufferWidth, gl.drawingBufferHeight);
		/* MATCH = 2; SKIP = -1; MISMATCH = -1; */
		let scores = program.uniforms.scores;
		let sValues = [2,-1,-1].map((d)=>{
			return d/256.0;
		});
		gl.uniform3fv(scores, sValues);
	}

	addProgram(name,fsSource){
		const gl = this.gl;

		// Vertex shader program
		const vsSource = (`
			precision mediump float;

			attribute vec2 a_position;
			attribute vec2 a_texCoord;

			uniform vec2 u_resolution;
			varying vec2 v_texCoord;

			void main() {
				// convert the rectangle from pixels to 0.0 to 1.0
				vec2 zeroToOne = a_position / u_resolution;
				vec2 zeroToTwo = zeroToOne * 2.0;
				vec2 clipSpace = zeroToTwo - 1.0;
				gl_Position = vec4(clipSpace * vec2(1, 1), 0, 1);
				// pass the texCoord to the fragment shader
				v_texCoord = a_texCoord;
			}
		`);

		let shaders = [
				{type:'VERTEX',typeId:gl.VERTEX_SHADER,source:vsSource},
				{type:'FRAGMENT',typeId:gl.FRAGMENT_SHADER,source:fsSource}
			]
			.map((s)=>{
				const shader = gl.createShader(s.typeId);
				gl.shaderSource(shader, s.source);
				gl.compileShader(shader);
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					gl.deleteShader(shader);
					throw new Error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
				}
				s.shader = shader;
				return s;
			})
			.reduce((a,d)=>{
				a[d.type] = d;
				return a;
			},{})
			;

		// Create the shader program
		const shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, shaders.VERTEX.shader);
		gl.attachShader(shaderProgram, shaders.FRAGMENT.shader);
		gl.linkProgram(shaderProgram);

		gl.deleteShader(shaders.VERTEX.shader);
		gl.deleteShader(shaders.FRAGMENT.shader);

		// If creating the shader program failed
		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			throw new Error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
		}

		this._.programs[name] = {
			program: shaderProgram,
			attribs:{
				position: gl.getAttribLocation(shaderProgram, "a_position"),
				texcoord: gl.getAttribLocation(shaderProgram, "a_texCoord"),
			},
			uniforms:{
				resolution: gl.getUniformLocation(shaderProgram, "u_resolution"),
				scores: gl.getUniformLocation(shaderProgram, "scores"),
			}
		};
		return this;

	}
}


/**************************************************************/


main();

/**
 * Start here
 */
function main() {

/*
Cycles......: 430
Timings (ms): 1854.8
 * init: 16.3;
 * frames: 5.5;
 * chains: 1837.0;
*/
	let submissions = [
			// ~10 ms based on CPU
			'PELLICAN',
			'COELACANTH',
			// 5.5 seconds based on CPU
			//'In maxime voluptates veniam sed eum aut soluta. Commodi modi aliquam reprehenderit quia eveniet nemo non modi. Quaerat doloribus ut id est corrupti. Facilis et consequatur',
			//'Repudiandae quam ratione neque minus. Consectetur soluta dicta est quidem accusamus cumque. Et fugiat quia consequatur aut. Deleniti alias itaque incidunt ad in omnis. Dolores hic vitae rerum ad possimus rem repellat. Voluptatem in similique labore reiciendis.',
		]
		.map(d=>{
			return d
				.toLowerCase()
				.split('')
				.map(c=>{return c.charCodeAt(0);})
				;
		})
		.sort((a,b)=>{
			return a.length - b.length;
		});
	let swVals = {
		MAX_RECORDS:Math.max(submissions[0].length,submissions[1].length),
		total_cycles: submissions[0].length+submissions[1].length-1,
		total_area: submissions[0].length*submissions[1].length,
		rec: 0,
		cycle:0,
		inbound:{
			a:submissions[0],
			b:submissions[1],
		},
	};

	const gpu = new psGpu({width:submissions[0].length,height:submissions[1].length});
	gpu.addProgram('smithwaterman', `
		precision mediump float;

		// our texture
		uniform sampler2D u_image;
		// the texCoords passed in from the vertex shader.
		varying vec2 v_texCoord;

		// constants
		uniform vec2 u_resolution;
		uniform vec3 scores;

		void main() {

			/*******************************/
			// calculate the size of a pixel
			vec2 pixSize = vec2(1.0, 1.0) / u_resolution;
			vec4 pixNull = vec4(0.0,0.0,0.0,0.0);
			// find our four critical points
			vec4 here = texture2D(u_image, v_texCoord);
			vec4 nw   = texture2D(u_image, v_texCoord + vec2(-pixSize.x,-pixSize.y));
			vec4 w    = texture2D(u_image, v_texCoord + vec2(-pixSize.x,         0));
			vec4 n    = texture2D(u_image, v_texCoord + vec2(         0,-pixSize.y));
			// test for out of bounds values
			if(v_texCoord.y <= pixSize.y){
				nw = pixNull;
				n = pixNull;
			}
			if(v_texCoord.x <= pixSize.x){
				nw = pixNull;
				w = pixNull;
			}
			// Find the max score from the chain
			here.b = max(w.a, n.a);
			here.b = max(here.b, nw.a);
			// add up our new score
			here.a  = here.b + here.r;

			// Figure out what the directionality of the score was
			if(nw.a == here.b){
				here.b = 3.0/256.0;
			}
			else if(w.a == here.b){
				here.b = 2.0/256.0;
			}
			else{
				here.b = 1.0/256.0;
			}

			// apply the skip penalty if it was anything but NW
			here.a += scores.z * (here.b==float(3) ? float(0) : float(1));
			/*******************************/

			gl_FragColor = here;
		}
	`);

	gpu.addProgram('initializeSpace', `
		precision mediump float;

		// our texture
		uniform sampler2D u_image;
		// the texCoords passed in from the vertex shader.
		varying vec2 v_texCoord;

		// constants
		uniform vec2 u_resolution;
		uniform vec3 scores;

		void main() {
			vec4 w = texture2D(u_image, vec2(v_texCoord.x,0));
			vec4 n = texture2D(u_image, vec2(0,v_texCoord.y));
			float score = 0.0;
			score = (w.rg == n.ba) ? scores.x : scores.y;
			gl_FragColor = vec4(score,0,0,score);
		}
	`);

	gpu.initMemory();

	// Initialize the workspace
	window.performance.mark('init.start');
	let data = gpu.emptyData();
	let data16 = new Uint16Array(data.buffer);
	for(let x=0,pos=0; x < gpu.width; x++,pos+=2){
		data16[pos] = swVals.inbound.a[x];
	}
	for(let y=0,pos=1; y < gpu.height; y++,pos+=(gpu.width*2)){
		data16[pos] = swVals.inbound.b[y];
	}
	// Write the values to the image
	gpu.write(data);
	gpu.run('initializeSpace');
	window.performance.mark('init.end');
	window.performance.measure('init','init.start','init.end');

	drawGrid(gpu,swVals);

	window.performance.mark('frames.start');
	for(swVals.cycle=0; swVals.cycle < swVals.total_cycles; swVals.cycle++){
		gpu.run('smithwaterman');
	}
	window.performance.mark('frames.end');
	window.performance.measure('frames','frames.start','frames.end');

	drawGrid(gpu,swVals);

	window.performance.mark('chains.start');
	data = gpu.read();
	let chains = ResolveChains(swVals,data,gpu.gl.drawingBufferWidth,gpu.gl.drawingBufferHeight);
	window.performance.mark('chains.end');
	window.performance.measure('chains','chains.start','chains.end');

	drawGrid(gpu,swVals);
	drawChains(chains);
}


function ResolveChains(swVals,values, width, height){
	const MIN_SIGNIFICANT = 3;
	const MAX_CHAINS = 10;
	const modDir = [
			[0,0], // don't move
			[0,1],
			[1,0],
			[1,1]
		];

	let index = new Map();
	for(let i=swVals.total_area-1; i>=0; i-=1){
		let pix = new pixel(values,i*4);
		if(pix.a === 0) continue;

		let d = {
			i: i,
			score: pix.a,
			chain:[]
		};

		let md = modDir[pix.b%modDir.length];
		d.prev = i;
		d.prev -= md[0] * 1;
		d.prev -= md[1] * width;
		index.set(d.i, d);
	}
	let chains = [];
	while(index.size > 0){
		let root = Array.from(index.values())
			.sort((a,b)=>{
				let ord = b.score - a.score;
				if(ord === 0){
					ord = a.i - b.i;
				}
				return ord;
			})
			.shift()
			;

		for(let item = root; item; item = index.get(item.prev)){
			root.chain.push(item);
			index.delete(item.i);
		}
		let finItem = root.chain[root.chain.length-1];
		root.score -= Math.max(0,finItem.score-2);
		if(root && root.score >= MIN_SIGNIFICANT){
			chains.push(root);
		}
	}
	chains = chains
		.sort((a,b)=>{
			let ord = b.score - a.score;
			if(ord === 0){
				ord = a.i - b.i;
			}
			return ord;
		})
		.slice(0,Math.min(MAX_CHAINS,chains.length))
		;
	return chains;
}


function drawGrid(gpu, runMetrics){

	let values = gpu.read();

	let table = document.querySelector("table");
	table.innerHTML = "<caption></caption><tbody></tbody>";


	let caption = table.querySelector('caption');
	let times = window.performance.getEntriesByType('measure');
	caption.innerHTML =
		'Cycles......: ' + runMetrics.cycle + '\n' +
		'Timings (ms): '+times.reduce((a,d)=>{return a+d.duration;},0).toFixed(1)+'<ul>' +
		times.map(d=>{
			return '<li>' + d.name + ': ' + d.duration.toFixed(1) + ';</li>';
		}).join('') +
		'</ul>'
		;

	table = table.tBodies[0];
	table.innerHTML = '';
	let tr = table.insertRow(-1);
	let th = document.createElement('th');
	th.innerHTML = '&nbsp;';
	tr.append(th);
	runMetrics.inbound.a.forEach((d,i)=>{
		let th = document.createElement('th');
		th.innerHTML = String.fromCharCode(d).toUpperCase() + '<sub>'+i+'</sub>';
		tr.append(th);
	});
	for(let y=0,i=0; y<gpu.gl.drawingBufferHeight ; y++){
		tr = table.insertRow(-1);
		let th = document.createElement('th');
		th.innerHTML = String.fromCharCode(runMetrics.inbound.b[y]).toUpperCase() + '<sub>'+y+'</sub>';
		tr.append(th);
		for(let x=0; x<gpu.gl.drawingBufferWidth ; x++,i++){
			let pix = new pixel(values,i*4);

			let td = document.createElement('td');
			td.innerHTML = pix.values
				.map(d=>{
					let str = d.toString().split('');
					while(str.length < 3){
						str.unshift(String.fromCharCode(160));
					}
					str = str.join('');
					return '<i>' + str + '</i>';
				})
				.join(' ')
				;
			tr.append(td);
		}
	}

}

function drawChains(chains){
	let tds = Array.from(document.querySelectorAll('td'));
	let ths = Array.from(document.querySelectorAll('th'));
	const colours = ['5DA5DA','4D4D4D','FAA43A','60BD68','F17CB0','B2912F','B276B2','DECF3F','F15854'];
	chains.slice(0,colours.length).forEach((chain)=>{
		let colour = colours.shift();
		chain.chain.forEach(d=>{
			let tomark = [];
			tomark.push(tds[d.i]);
			tomark.push(tds[d.i].parentElement.querySelector('th'));
			tomark.push(ths[tds[d.i].cellIndex]);
			tomark.forEach((td)=>{
				if(td.style.backgroundColor === ''){
					td.style.backgroundColor = 'white';
					let easement = (Math.random()*500);
					setTimeout(()=>{
						td.style.transition = 'background-color 0.5s';
						td.style.backgroundColor = '#'+colour;
						td.style.textShadow = '0 0 5px white';
						td.style.fontWeight = 'bold';
					},easement);
				}
			});
		});
	});
}
  </script>
 </body>

</html>
