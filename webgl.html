<!doctype html>
<html lang="en">
  <head>
   <meta charset="utf-8">
   <title>WebGL Demo</title>
   <style>
	body{
		font-family:monospace;
	}
	canvas{
		border:1em solid #888888;
	}
	table{
		text-align:right;
		border-collapse: collapse;
	}
	table, th, td {
		border: 1px solid lightgray;
		white-space: pre;
	}
	td > i{
		 font-style: normal;
	}
	td > i:nth-of-type(1){
		color:red;
	}
	td > i:nth-of-type(2){
		color:green;
	}
	td > i:nth-of-type(3){
		color:blue;
	}
	td > i:nth-of-type(4){
		color:black;
	}
	td > i:nth-of-type(2):after{
		content:"\A";
	}
	table > caption{
		text-align:left;
	}
   </style>
  </head>

 <body>
  <canvas height='1' width='1'></canvas>
  <table></table>
  <pre></pre>
  <script>
class pixel{
	constructor(pixels=[0,0,0,0], offset = 0){
		this.offset = offset;
		this.pixels = pixels;
	}

	get r(){ return this.getValue(0); }
	get g(){ return this.getValue(1); }
	get b(){ return this.getValue(2); }
	get a(){ return this.getValue(3); }

	set r(vals){ this.setValue(0,vals); }
	set g(vals){ this.setValue(1,vals); }
	set b(vals){ this.setValue(2,vals); }
	set a(vals){ this.setValue(3,vals); }

	setValue(offset,vals){
		if(vals < 0){
			vals = 0;
		}
		if(vals > 255){
			vals = 255;
		}
		this.pixels[this.offset+offset] = vals;
	}

	getValue(offset){
		let value = this.offset+offset;
		value = this.pixels[value];
		value = pixel.NZ(value);
		return value;
	}

	read(arr,offset){
		this.r = arr[offset+0];
		this.g = arr[offset+1];
		this.b = arr[offset+2];
		this.a = arr[offset+3];
		return offset+4;
	}

	write(arr,offset){
		arr[offset+0] = this.r;
		arr[offset+1] = this.g;
		arr[offset+2] = this.b;
		arr[offset+3] = this.a;
		return offset+4;
	}

	get values(){
		return [
				this.r,
				this.g,
				this.b,
				this.a,
			];
	}

	static NZ(val){
		return val ? val : 0;
	}
}

class psGpu{
	constructor(options={}){
		let opts = psGpu.BaseOpts;
		Object.entries(options).forEach((o)=>{
			opts[o[0]] = o[1];
		});

		let canvas = document.createElement('canvas');
		canvas.height = opts.height;
		canvas.width = opts.width;

		const gl = canvas.getContext('webgl2', {preserveDrawingBuffer: true});
		// If we don't have a GL context, give up now
		if (!gl) {
			throw new Error('Unable to initialize WebGL. Your browser or machine may not support it.');
		}


		this._ = {
			opts: opts,
			canvas:canvas,
			gl:gl,
		};

	}

	get gl(){
		return this._.gl;
	}

	static get BaseOpts(){
		return {
			height:1,
			width:1,
		};
	}
}


main();

/**
 * Start here
 */
function main() {

	let submissions = [
			// ~10 ms based on CPU
			'PELLICAN',
			'COELACANTH',
			// 5.5 seconds based on CPU
			//'In maxime voluptates veniam sed eum aut soluta. Commodi modi aliquam reprehenderit quia eveniet nemo non modi. Quaerat doloribus ut id est corrupti. Facilis et consequatur',
			//'Repudiandae quam ratione neque minus. Consectetur soluta dicta est quidem accusamus cumque. Et fugiat quia consequatur aut. Deleniti alias itaque incidunt ad in omnis. Dolores hic vitae rerum ad possimus rem repellat. Voluptatem in similique labore reiciendis.',
		]
		.map(d=>{
			return d
				.toLowerCase()
				.split('')
				.map(c=>{return c.charCodeAt(0);})
				;
		})
		.sort((a,b)=>{
			return a.length - b.length;
		});

	const gpu = new psGpu({width:submissions[0].length,height:submissions[1].length});
	const gl = gpu.gl;

	// Vertex shader program
	const vsSource = (`
		precision mediump float;

		attribute vec2 a_position;
		attribute vec2 a_texCoord;

		uniform vec2 u_resolution;

		varying vec2 v_texCoord;

		void main() {
			// convert the rectangle from pixels to 0.0 to 1.0
			vec2 zeroToOne = a_position / u_resolution;

			// convert from 0->1 to 0->2
			vec2 zeroToTwo = zeroToOne * 2.0;

			// convert from 0->2 to -1->+1 (clipspace)
			vec2 clipSpace = zeroToTwo - 1.0;

			gl_Position = vec4(clipSpace * vec2(1, 1), 0, 1);

			// pass the texCoord to the fragment shader
			// The GPU will interpolate this value between points.
			v_texCoord = a_texCoord;
		}
	`);

	// Fragment shader program
	const fsSource = (`
		precision mediump float;

		// our texture
		uniform sampler2D u_image;
		// the texCoords passed in from the vertex shader.
		varying vec2 v_texCoord;

		// constants
		uniform vec2 u_resolution;
		uniform vec3 scores;

		void main() {

			/*******************************/
			// calculate the size of a pixel
			vec2 pixSize = vec2(1.0, 1.0) / u_resolution;
			vec4 pixNull = vec4(0.0,0.0,0.0,0.0);
			// find our four critical points
			vec4 here = texture2D(u_image, v_texCoord);
			vec4 nw   = texture2D(u_image, v_texCoord + vec2(-pixSize.x,-pixSize.y));
			vec4 w    = texture2D(u_image, v_texCoord + vec2(-pixSize.x,         0));
			vec4 n    = texture2D(u_image, v_texCoord + vec2(         0,-pixSize.y));
			// test for out of bounds values
			if(v_texCoord.y <= pixSize.y){
				nw = pixNull;
				n = pixNull;
			}
			if(v_texCoord.x <= pixSize.x){
				nw = pixNull;
				w = pixNull;
			}
			// Find the max score from the chain
			here.b = max(w.a, n.a);
			here.b = max(here.b, nw.a);
			// add up our new score
			here.a  = here.b;
			here.a += (here.r == here.g) ? scores.x : scores.y;

			// Figure out what the directionality of the score was
			if(nw.a == here.b){
				here.b = 3.0/256.0;
			}
			else if(w.a == here.b){
				here.b = 2.0/256.0;
			}
			else{
				here.b = 1.0/256.0;
			}

			// apply the skip penalty if it was anything but NW
			here.a += scores.z * (here.b==float(3) ? float(0) : float(1));
			/*******************************/

			gl_FragColor = here;
		}
	`);

	// Initialize a shader program; this is where all the lighting
	// for the vertices and so forth is established.
	const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

	// Collect all the info needed to use the shader program.
	// Look up which attribute our shader program is using
	// for aVertexPosition and look up uniform locations.
	const programInfo = {
		gl:gl,
		program: shaderProgram,
		attribLocations: {
			vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
			textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
		},
		uniformLocations: {
			uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
		},
		buffers:{
			texture:null,
		},
		dimensions:{
			height: gpu.gl.drawingBufferHeight,
			width:  gpu.gl.drawingBufferWidth,
		},
		ProcessFrame: ProcessFrameGPU
	};

	let swVals = {
		MAX_RECORDS:Math.max(submissions[0].length,submissions[1].length),
		total_cycles: submissions[0].length+submissions[1].length-1,
		total_area: submissions[0].length*submissions[1].length,
		rec: 0,
		cycle:0,
		inbound:{
			a:submissions[0],
			b:submissions[1],
		},
	};
	render(programInfo);

	// This could be done awesomely in a single pass as a GPU program
	window.performance.mark('init.start');
	const data = readNumbers(gpu);
	let x = 0;
	let y = 0;
	for(let pos=0; pos < data.length; pos+=4){
		data[pos+0] = swVals.inbound.a[x];
		data[pos+1] = swVals.inbound.b[y];
		data[pos+2] = 0;
		data[pos+3] = 0;
		x = (x+1)%programInfo.dimensions.width;
		if(x === 0){
			y = (y+1)%programInfo.dimensions.height;
		}
	}
	// Write the values ot the image
	writeNumbers(programInfo,data);
	run(programInfo);
	window.performance.mark('init.end');
	window.performance.measure('init','init.start','init.end');

	drawGrid(programInfo,swVals);

	window.performance.mark('frames.start');
	for(swVals.cycle=0; swVals.cycle < swVals.total_cycles; swVals.cycle++){
		programInfo.ProcessFrame(programInfo);
	}
	window.performance.mark('frames.end');
	window.performance.measure('frames','frames.start','frames.end');

	drawGrid(programInfo,swVals);

	window.performance.mark('chains.start');
	let chains = ResolveChains(swVals,readNumbers(programInfo),gpu.gl.drawingBufferWidth,gpu.gl.drawingBufferHeight);
	window.performance.mark('chains.end');
	window.performance.measure('chains','chains.start','chains.end');

	drawGrid(programInfo,swVals);
	drawChains(chains);
}


function render(programInfo) {
	let gl = programInfo.gl;
	// setup GLSL program
	var program = programInfo.program;

	// look up where the vertex data needs to go.
	var positionLocation = gl.getAttribLocation(program, "a_position");
	var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");

	// Create a buffer to put three 2d clip space points in
	var positionBuffer = gl.createBuffer();

	// Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
	gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
	// Set a rectangle the same size as the image.
	setRectangle(gl, 0, 0, programInfo.dimensions.width, programInfo.dimensions.height);

	// provide texture coordinates for the rectangle.
	var texcoordBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			0.0,  0.0,
			1.0,  0.0,
			0.0,  1.0,
			0.0,  1.0,
			1.0,  0.0,
			1.0,  1.0,
		]), gl.STATIC_DRAW);

	// Create a texture.
	const pixel = new Uint8Array(gl.drawingBufferWidth*gl.drawingBufferHeight*4);
	programInfo.textures = [0,1].map(d=>{
			let texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.drawingBufferWidth, gl.drawingBufferHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixel, 0);

			// Not concerned with it being a power of 2
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

			let frameBuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
		    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

			return {
				id: d,
				texture: texture,
				framebuffer: frameBuffer,
			};
		});


	// Tell WebGL how to convert from clip space to pixels
	gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

	// Clear the canvas
	gl.clearColor(0, 0, 0, 0);
	gl.clear(gl.COLOR_BUFFER_BIT);

	// Tell it to use our program (pair of shaders)
	gl.useProgram(program);

	// Turn on the position attribute
	gl.enableVertexAttribArray(positionLocation);

	// Bind the position buffer.
	gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

	// Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
	var size = 2;          // 2 components per iteration
	var type = gl.FLOAT;   // the data is 32bit floats
	var normalize = false; // don't normalize the data
	var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
	var offset = 0;        // start at the beginning of the buffer
	gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);

	// Turn on the teccord attribute
	gl.enableVertexAttribArray(texcoordLocation);

	// Bind the position buffer.
	gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);

	// Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
	var size = 2;          // 2 components per iteration
	var type = gl.FLOAT;   // the data is 32bit floats
	var normalize = false; // don't normalize the data
	var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
	var offset = 0;        // start at the beginning of the buffer
	gl.vertexAttribPointer(texcoordLocation, size, type, normalize, stride, offset);

	// lookup uniforms
	let resolutionLocation = gl.getUniformLocation(program, "u_resolution");
	gl.uniform2f(resolutionLocation, gl.drawingBufferWidth, gl.drawingBufferHeight);
	/*
	const MATCH = 2;
	const SKIP = -1;
	const MISMATCH = -1;
	*/
	let scores = gl.getUniformLocation(program, "scores");
	let sValues = [2,-1,-1].map((d)=>{
		return d/128.0;
	});
	gl.uniform3fv(scores, sValues);


	// Draw the rectangle.
	flush(programInfo);
}

function flush(programInfo){
	programInfo.gl.bindFramebuffer(programInfo.gl.FRAMEBUFFER, null);
	run(programInfo);
	programInfo.gl.bindFramebuffer(programInfo.gl.FRAMEBUFFER, programInfo.textures[0].framebuffer);
}

function run(programInfo){
	programInfo.gl.drawArrays(programInfo.gl.TRIANGLES, 0, 6);
}


function setRectangle(gl, x, y, width, height) {
	var x1 = x;
	var x2 = x + width;
	var y1 = y;
	var y2 = y + height;

	// NOTE: gl.bufferData(gl.ARRAY_BUFFER, ...) will affect
	// whatever buffer is bound to the `ARRAY_BUFFER` bind point
	// but so far we only have one buffer. If we had more than one
	// buffer we'd want to bind that buffer to `ARRAY_BUFFER` first.

	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
		x1, y1,
		x2, y1,
		x1, y2,
		x1, y2,
		x2, y1,
		x2, y2])
		, gl.STATIC_DRAW);
}


/**
 * Initialize a shader program, so WebGL knows how to draw our data
 */
function initShaderProgram(gl, vsSource, fsSource) {
	const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
	const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

	// Create the shader program
	const shaderProgram = gl.createProgram();
	gl.attachShader(shaderProgram, vertexShader);
	gl.attachShader(shaderProgram, fragmentShader);
	gl.linkProgram(shaderProgram);

	gl.deleteShader(vertexShader);
	gl.deleteShader(fragmentShader);

	// If creating the shader program failed
	if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
		return null;
	}

	return shaderProgram;
}

/**
 * creates a shader of the given type, uploads the source and
 * compiles it.
 */
function loadShader(gl, type, source) {
	const shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
		gl.deleteShader(shader);
		return null;
	}
	return shader;
}


function readNumbers(psGpu, dim={}){
	let gl = psGpu.gl;

	dim.x = dim.x || 0;
	dim.y = dim.y || 0;
	dim.width = dim.width || psGpu.gl.drawingBufferWidth;
	dim.height = dim.height || psGpu.gl.drawingBufferHeight;
	if(psGpu.gl.drawingBufferWidth < dim.width+dim.x){
		dim.width = psGpu.gl.drawingBufferWidth - dim.x;
	}
	if(psGpu.gl.drawingBufferHeight < dim.height+dim.y){
		dim.height = psGpu.gl.drawingBufferHeight - dim.y;
	}

	//flush(psGpu);

	let pixels = new Uint8Array(dim.width * dim.height * 4);
	gl.readPixels(dim.x, dim.y, dim.width, dim.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels, 0);
	return pixels;
}

function writeNumbers(psGpu, pixels, dim={}){
	let gl = psGpu.gl;

	dim.x = dim.x || 0;
	dim.y = dim.y || 0;
	dim.width = dim.width || psGpu.gl.drawingBufferWidth;
	dim.height = dim.height || psGpu.gl.drawingBufferHeight;
	if(psGpu.gl.drawingBufferWidth < dim.width+dim.x){
		dim.width = psGpu.gl.drawingBufferWidth - dim.x;
	}
	if(psGpu.gl.drawingBufferHeight < dim.height+dim.y){
		dim.height = psGpu.gl.drawingBufferHeight - dim.y;
	}

	gl.texSubImage2D(gl.TEXTURE_2D, 0, dim.x, dim.y, dim.width, dim.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels , 0);
}

function ProcessFrameGPU(programInfo){
	let buffer = programInfo.textures.shift();
	programInfo.textures.push(buffer);

	programInfo.gl.bindFramebuffer(programInfo.gl.FRAMEBUFFER, buffer.framebuffer);
	run(programInfo);
	programInfo.gl.bindTexture(programInfo.gl.TEXTURE_2D, buffer.texture);
}



function ResolveChains(swVals,values, width, height){
	const MIN_SIGNIFICANT = 3;
	const MAX_CHAINS = 10;
	const modDir = [
			[0,0], // don't move
			[0,1],
			[1,0],
			[1,1]
		];

	let index = new Map();
	for(let i=swVals.total_area-1; i>=0; i-=1){
		let pix = new pixel(values,i*4);
		if(pix.a === 0) continue;

		let d = {
			i: i,
			score: pix.a,
			chain:[]
		};

		let md = modDir[pix.b%modDir.length];
		d.prev = i;
		d.prev -= md[0] * 1;
		d.prev -= md[1] * width;
		index.set(d.i, d);
	}
	let chains = [];
	while(index.size > 0){
		let root = Array.from(index.values())
			.sort((a,b)=>{
				let ord = b.score - a.score;
				if(ord === 0){
					ord = a.i - b.i;
				}
				return ord;
			})
			.shift()
			;

		for(let item = root; item; item = index.get(item.prev)){
			root.chain.push(item);
			index.delete(item.i);
		}
		let finItem = root.chain[root.chain.length-1];
		root.score -= finItem.score-2;
		if(root && root.score >= MIN_SIGNIFICANT){
			chains.push(root);
		}
	}
	chains = chains
		.sort((a,b)=>{
			let ord = b.score - a.score;
			if(ord === 0){
				ord = a.i - b.i;
			}
			return ord;
		})
		.slice(0,Math.min(MAX_CHAINS,chains.length))
		;
	return chains;
}


function drawGrid(programInfo, runMetrics){

	let values = readNumbers(programInfo);

	let table = document.querySelector("table");
	table.innerHTML = "<caption></caption><tbody></tbody>";


	let caption = table.querySelector('caption');
	let times = performance.getEntriesByType('measure');
	caption.innerHTML =
		'Cycles......: ' + runMetrics.cycle + '\n' +
		'Timings (ms): '+times.reduce((a,d)=>{return a+d.duration;},0)+'<ul>' +
		times.map(d=>{
			return '<li>' + d.name + ': ' + d.duration + ';</li>';
		}).join('') +
		'</ul>'
		;

	table = table.tBodies[0];
	table.innerHTML = '';
	let tr = table.insertRow(-1);
	let th = document.createElement('th');
	th.innerHTML = '&nbsp;';
	tr.append(th);
	runMetrics.inbound.a.forEach((d,i)=>{
		let th = document.createElement('th');
		th.innerHTML = String.fromCharCode(d).toUpperCase() + '<sub>'+i+'</sub>';
		tr.append(th);
	});
	for(let y=0,i=0; y<programInfo.dimensions.height ; y++){
		tr = table.insertRow(-1);
		let th = document.createElement('th');
		th.innerHTML = String.fromCharCode(runMetrics.inbound.b[y]).toUpperCase() + '<sub>'+y+'</sub>';
		tr.append(th);
		for(let x=0; x<programInfo.dimensions.width ; x++,i++){
			let pix = new pixel(values,i*4);

			let td = document.createElement('td');
			td.innerHTML = pix.values
				.map(d=>{
					let str = d.toString().split('');
					while(str.length < 3){
						str.unshift(String.fromCharCode(160));
					}
					str = str.join('');
					return '<i>' + str + '</i>';
				})
				.join(' ')
				;
			tr.append(td);
		}
	}

}

function drawChains(chains){
	let tds = Array.from(document.querySelectorAll('td'));
	let ths = Array.from(document.querySelectorAll('th'));
	const colours = ['5DA5DA','4D4D4D','FAA43A','60BD68','F17CB0','B2912F','B276B2','DECF3F','F15854'];
	chains.slice(0,colours.length).forEach((chain)=>{
		let colour = colours.shift();
		chain.chain.forEach(d=>{
			let tomark = [];
			tomark.push(tds[d.i]);
			tomark.push(tds[d.i].parentElement.querySelector('th'));
			tomark.push(ths[tds[d.i].cellIndex]);
			tomark.forEach((td)=>{
				if(td.style.backgroundColor === ''){
					td.style.backgroundColor = 'white';
					let easement = (Math.random()*500);
					setTimeout(()=>{
						td.style.transition = 'background-color 0.5s';
						td.style.backgroundColor = '#'+colour;
						td.style.textShadow = '0 0 5px white';
						td.style.fontWeight = 'bold';
					},easement);
				}
			});
		});
	});
}
  </script>
 </body>

</html>
