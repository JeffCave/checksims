<!doctype html>
<html lang="en">
  <head>
   <meta charset="utf-8">
   <title>WebGL Demo</title>
   <style>
	canvas{
		border:1em solid #888888;
	}
   </style>
  </head>

 <body>
  <canvas height='1' width='1'></canvas>
  <script>
class pixel{
	constructor(pixels=[0,0,0,0], offset = 0){
		this.offset = offset;
		this.pixels = pixels;
	}

	get r(){ return this.getValue(0); }
	get g(){ return this.getValue(1); }
	get b(){ return this.getValue(2); }
	get a(){ return this.getValue(3); }

	set r(vals){ this.setValue(0,vals); }
	set g(vals){ this.setValue(1,vals); }
	set b(vals){ this.setValue(2,vals); }
	set a(vals){ this.setValue(3,vals); }

	setValue(offset,vals){
		if(vals < 0){
			vals = 0;
		}
		if(vals > 255){
			vals = 255;
		}
		this.pixels[this.offset+offset] = vals;
	}

	getValue(offset){
		let value = this.offset+offset;
		value = this.pixels[value];
		value = pixel.NZ(value);
		return value;
	}

	read(arr,offset){
		this.r = arr[offset+0];
		this.g = arr[offset+1];
		this.b = arr[offset+2];
		this.c = arr[offset+3];
		return offset+4;
	}

	write(arr,offset){
		arr[offset+0] = this.r;
		arr[offset+1] = this.g;
		arr[offset+2] = this.b;
		arr[offset+3] = this.a;
		return offset+4;
	}

	static NZ(val){
		return val ? val : 0;
	}
}




main();

/**
 * Start here
 */
function main() {
	const canvas = document.querySelector('canvas');
	const gl = canvas.getContext('webgl2', {preserveDrawingBuffer: true});

	let submissions = [
			'PELLICAN'  .split('').map(c=>{return c.charCodeAt(0);}),
			'COELACANTH'.split('').map(c=>{return c.charCodeAt(0);}),
		]
		.sort((a,b)=>{
			return a.length - b.length;
		});

	canvas.width = submissions[0].length;
	canvas.height= submissions[1].length;



	// If we don't have a GL context, give up now
	if (!gl) {
		console.error('Unable to initialize WebGL. Your browser or machine may not support it.');
		return;
	}

	// Vertex shader program
	const vsSource = (`
		attribute vec2 a_position;
		attribute vec2 a_texCoord;

		uniform vec2 u_resolution;

		varying vec2 v_texCoord;

		void main() {
			// convert the rectangle from pixels to 0.0 to 1.0
			vec2 zeroToOne = a_position / u_resolution;

			// convert from 0->1 to 0->2
			vec2 zeroToTwo = zeroToOne * 2.0;

			// convert from 0->2 to -1->+1 (clipspace)
			vec2 clipSpace = zeroToTwo - 1.0;

			gl_Position = vec4(clipSpace * vec2(1, 1), 0, 1);

			// pass the texCoord to the fragment shader
			// The GPU will interpolate this value between points.
			v_texCoord = a_texCoord;
		}
	`);

	// Fragment shader program
	const fsSource = (`
		precision mediump float;

		// our texture
		uniform sampler2D u_image;

		// the texCoords passed in from the vertex shader.
		varying vec2 v_texCoord;

		void main() {
			gl_FragColor = texture2D(u_image, v_texCoord);
		}
	`);

	// Initialize a shader program; this is where all the lighting
	// for the vertices and so forth is established.
	const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

	// Collect all the info needed to use the shader program.
	// Look up which attribute our shader program is using
	// for aVertexPosition and look up uniform locations.
	const programInfo = {
		gl:gl,
		program: shaderProgram,
		attribLocations: {
			vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
			textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
		},
		uniformLocations: {
			uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
		},
		buffers:{
			texture:null,
		},
		dimensions:{
			height: canvas.height,
			width:  canvas.width,
		},
		content:{
			MAX_RECORDS:canvas.height-1,
			total_cycles: submissions[0].length+submissions[1].length-1,
			total_area: submissions[0].length*submissions[1].length,
			rec: 0,
			cycle:0,
			inbound:{
				a:submissions[0],
				b:submissions[1],
			},
		}
	};

	render(programInfo);

	// This could be done awesomely in a single pass as a GPU program
	const data = readNumbers(programInfo);
	let x = 0;
	let y = 0;
	for(let pos=0; pos < data.length; pos+=4){
		data[pos+0] = programInfo.content.inbound.a[x];
		data[pos+1] = programInfo.content.inbound.b[y];
		data[pos+2] = 0;
		data[pos+3] = 255;
		x = (x+1)%programInfo.dimensions.width;
		if(x === 0){
			y = (y+1)%programInfo.dimensions.height;
		}
	}
	// Write the values ot the image
	writeNumbers(programInfo,data);
	flush(programInfo);


	programInfo.content.timer = setInterval(ProcessFrame,16,programInfo);
	ProcessFrame(programInfo);


}


function render(programInfo) {
	let gl = programInfo.gl;
	// setup GLSL program
	var program = programInfo.program;

	// look up where the vertex data needs to go.
	var positionLocation = gl.getAttribLocation(program, "a_position");
	var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");

	// Create a buffer to put three 2d clip space points in
	var positionBuffer = gl.createBuffer();

	// Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
	gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
	// Set a rectangle the same size as the image.
	setRectangle(gl, 0, 0, programInfo.dimensions.width, programInfo.dimensions.height);

	// provide texture coordinates for the rectangle.
	var texcoordBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			0.0,  0.0,
			1.0,  0.0,
			0.0,  1.0,
			0.0,  1.0,
			1.0,  0.0,
			1.0,  1.0,
		]), gl.STATIC_DRAW);

	// Create a texture.
	programInfo.texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, programInfo.texture);
	const pixel = new Uint8Array(programInfo.dimensions.width*programInfo.dimensions.height*4);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, programInfo.dimensions.width, programInfo.dimensions.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixel, 0);

	// Not concerned with it being a power of 2
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);


	// lookup uniforms
	var resolutionLocation = gl.getUniformLocation(program, "u_resolution");

	// Tell WebGL how to convert from clip space to pixels
	gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

	// Clear the canvas
	gl.clearColor(0, 0, 0, 0);
	gl.clear(gl.COLOR_BUFFER_BIT);

	// Tell it to use our program (pair of shaders)
	gl.useProgram(program);

	// Turn on the position attribute
	gl.enableVertexAttribArray(positionLocation);

	// Bind the position buffer.
	gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

	// Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
	var size = 2;          // 2 components per iteration
	var type = gl.FLOAT;   // the data is 32bit floats
	var normalize = false; // don't normalize the data
	var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
	var offset = 0;        // start at the beginning of the buffer
	gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);

	// Turn on the teccord attribute
	gl.enableVertexAttribArray(texcoordLocation);

	// Bind the position buffer.
	gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);

	// Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
	var size = 2;          // 2 components per iteration
	var type = gl.FLOAT;   // the data is 32bit floats
	var normalize = false; // don't normalize the data
	var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
	var offset = 0;        // start at the beginning of the buffer
	gl.vertexAttribPointer(texcoordLocation, size, type, normalize, stride, offset);

	// set the resolution
	gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

	// Draw the rectangle.
	flush(programInfo);
}

function flush(programInfo){
	programInfo.gl.drawArrays(programInfo.gl.TRIANGLES, 0, 6);
}


function setRectangle(gl, x, y, width, height) {
	var x1 = x;
	var x2 = x + width;
	var y1 = y;
	var y2 = y + height;

	// NOTE: gl.bufferData(gl.ARRAY_BUFFER, ...) will affect
	// whatever buffer is bound to the `ARRAY_BUFFER` bind point
	// but so far we only have one buffer. If we had more than one
	// buffer we'd want to bind that buffer to `ARRAY_BUFFER` first.

	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
		x1, y1,
		x2, y1,
		x1, y2,
		x1, y2,
		x2, y1,
		x2, y2])
		, gl.STATIC_DRAW);
}


/**
 * Initialize a shader program, so WebGL knows how to draw our data
 */
function initShaderProgram(gl, vsSource, fsSource) {
	const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
	const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

	// Create the shader program
	const shaderProgram = gl.createProgram();
	gl.attachShader(shaderProgram, vertexShader);
	gl.attachShader(shaderProgram, fragmentShader);
	gl.linkProgram(shaderProgram);

	// If creating the shader program failed
	if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
		return null;
	}

	return shaderProgram;
}

/**
 * creates a shader of the given type, uploads the source and
 * compiles it.
 */
function loadShader(gl, type, source) {
	const shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
		gl.deleteShader(shader);
		return null;
	}
	return shader;
}


function readNumbers(psGpu, dim={}){
	let gl = psGpu.gl;

	dim.x = dim.x || 0;
	dim.y = dim.y || 0;
	dim.width = dim.width || psGpu.gl.drawingBufferWidth;
	dim.height = dim.height || psGpu.gl.drawingBufferHeight;
	if(psGpu.gl.drawingBufferWidth < dim.width+dim.x){
		dim.width = psGpu.gl.drawingBufferWidth - dim.x;
	}
	if(psGpu.gl.drawingBufferHeight < dim.height+dim.y){
		dim.height = psGpu.gl.drawingBufferHeight - dim.y;
	}

	let pixels = new Uint8Array(dim.width * dim.height * 4);
	gl.readPixels(dim.x, dim.y, dim.width, dim.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels, 0);
	return pixels;
}

function writeNumbers(psGpu, pixels, dim={}){
	let gl = psGpu.gl;

	dim.x = dim.x || 0;
	dim.y = dim.y || 0;
	dim.width = dim.width || psGpu.gl.drawingBufferWidth;
	dim.height = dim.height || psGpu.gl.drawingBufferHeight;
	if(psGpu.gl.drawingBufferWidth < dim.width+dim.x){
		dim.width = psGpu.gl.drawingBufferWidth - dim.x;
	}
	if(psGpu.gl.drawingBufferHeight < dim.height+dim.y){
		dim.height = psGpu.gl.drawingBufferHeight - dim.y;
	}

	gl.texSubImage2D(gl.TEXTURE_2D, 0, dim.x, dim.y, dim.width, dim.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels , 0);
}

function ProcessFrame(programInfo){

	// *** start: Everything here should be in a shader
	//let values = readNumbers(programInfo, 0, 0, 1, 1);
	const MATCH = 2;
	const SKIP = -1;
	const MISMATCH = -1;

	let vals = readNumbers(programInfo);
	let pWidth = 4;
	for(let y=programInfo.content.cycle,x=0; y>=0; y--,x++){
		// Out of bounds values.
		// self-handeld by OpenGL
		if(y >= programInfo.dimensions.height){
			x += y - programInfo.dimensions.height + 1;
			y = programInfo.dimensions.height - 1;
		}

		let coordHere = programInfo.dimensions.width*(y-0)+(x-0);
		let coordNW   = programInfo.dimensions.width*(y-1)+(x-1);
		let coordW    = programInfo.dimensions.width*(y-0)+(x-1);
		let coordN    = programInfo.dimensions.width*(y-1)+(x-0);

		// Out of bounds values.
		// this is handled on GPU
		if(x <= 0 || x >= programInfo.dimensions.width){
			coordNW = -1;
			coordW = -1;
		}
		if(y <= 0 || y >= programInfo.dimensions.height){
			coordNW = -1;
			coordN = -1;
		}

		let here = new pixel(vals, coordHere * pWidth);
		let nw   = new pixel(vals, coordNW   * pWidth);
		let w    = new pixel(vals, coordW    * pWidth);
		let n    = new pixel(vals, coordN    * pWidth);

		// Find the max score from the chain
		here.b = Math.max(w.a, n.a);
		here.b = Math.max(here.b, nw.a);
		// add up our new score
		here.a  = here.b;
		here.a += (here.r === here.g) ? MATCH : MISMATCH;
		// Figure out what the directionality of the score was
		if(nw.a === here.b){
			here.b = 0;
		}
		else if(w.a === here.b){
			here.b = 1;
		}
		else{
			here.b = 2;
		}

		// apply the skip penaly if it was anything but NW
		here.a += SKIP * (here.b===0) ? 0 : 1;

		programInfo.content.rec++;
		writeNumbers(programInfo, vals);
		flush(programInfo);
	}
	writeNumbers(programInfo, vals);
	// *** end: Everything here should be in a shader
	flush(programInfo);

	programInfo.content.cycle++;
	if(programInfo.content.cycle >= programInfo.content.total_cycles){
		clearInterval(programInfo.content.timer);
		setTimeout(ResolveChains,0,programInfo);
	}
}

function ResolveChains(programInfo){
	console.warn("Not yet implemented!");
}


  </script>
 </body>

</html>
